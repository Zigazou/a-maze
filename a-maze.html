<template id="a-maze">
  <style>
    div.container { position: relative; }

    /* The canvases will occupy as much space as possible. */
    canvas {
      width: 100%;
      height: auto;
    }

    /* The background canvas is the reference canvas, all the other canvases */
    /* go on top of it. */
    canvas:not(.background) {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>

  <div class="container">
    <!-- A stack of canvases. -->
    <canvas class="background"></canvas>
    <canvas class="objects"></canvas>
    <canvas class="hero"></canvas>
    <canvas class="light"></canvas>
  </div>
</template>

<script>
class AMaze extends HTMLElement {
  constructor() {
    super()

    this.gridColumns = 0
    this.gridRows = 0
    this.cellWidth = 0
    this.cellHeight = 0
    this.spriteSheet = undefined
    this.spriteColumns = 0
    this.spriteRows = 0
    this.grid = [[]]
    this.heroSrcCol = 0
    this.heroSrcRow = 0

    this.root = this.attachShadow({ mode: 'open' })
    this.root.appendChild(AMaze.template.cloneNode(true))

    this.backgroundCanvas = this.root.querySelector("canvas.background")
    this.objectsCanvas = this.root.querySelector("canvas.objects")
    this.heroCanvas = this.root.querySelector("canvas.hero")
    this.lightCanvas = this.root.querySelector("canvas.light")
  }

  resetCanvases() {
    const canvases = [
      this.backgroundCanvas,
      this.objectsCanvas,
      this.heroCanvas,
      this.lightCanvas
    ]

    // Resize the canvases
    canvases.map(canvas => {
      canvas.width = this.gridColumns * this.cellWidth
      canvas.height = this.gridRows * this.cellHeight
    })

    // Switch off the lights
    const ctx = this.lightCanvas.getContext('2d')
    ctx.fillStyle = "black"
    ctx.fillRect(0, 0, this.lightCanvas.width, this.lightCanvas.height)

    // Draw background
    this.grid.forEach((row, y) => {
      row.forEach((coords, x) => {
        this.copySprite(this.backgroundCanvas, coords.x, coords.y, x, y)
      })
    })
  }

  loadGrid(grid) {
    this.grid = grid
    this.gridColumns = this.grid[0].length
    this.gridRows = this.grid.length

    return this
  }

  defineHero(col, row) {
    this.heroSrcCol = col
    this.heroSrcRow = row

    return this
  }

  moveHero(col, row) {
    this.heroCol = col
    this.heroRow = row

    // Clear the canvas
    const ctx = this.heroCanvas.getContext('2d')
    ctx.clearRect(0, 0, this.heroCanvas.width, this.heroCanvas.height)

    // Draw hero
    this.copySprite(this.heroCanvas, this.heroSrcCol, this.heroSrcRow, col, row)

    return this
  }

  loadSprites(url, cellWidth, cellHeight) {
    this.cellWidth = cellWidth
    this.cellHeight = cellHeight

    return new Promise((resolve, reject) => {
      this.spriteSheet = new Image()
      this.spriteSheet.onload = () => {
        this.resetCanvases()
        resolve()
      }
      this.spriteSheet.src = url
    })
  }

  lighten(column, row) {
    const ctx = this.lightCanvas.getContext('2d')
    const x = column * this.cellWidth + this.cellWidth / 2
    const y = row * this.cellHeight + this.cellWidth / 2
    const inner = this.cellWidth / 2
    const outer = this.cellWidth * 1.5

    const g = ctx.createRadialGradient(x, y, inner, x, y, outer)

    g.addColorStop(1, 'rgba(0,0,0,0)')
    g.addColorStop(0, 'rgba(0,0,0,0.9)')

    ctx.globalCompositeOperation = 'destination-out'
    ctx.fillStyle = g
    ctx.fillRect(x - outer, y - outer, outer * 2, outer * 2)
  }

  copySprite(canvas, srcCol, srcRow, dstCol, dstRow) {
    const ctx = canvas.getContext('2d')

    ctx.drawImage(
      // Source
      this.spriteSheet,
      srcCol * this.cellWidth,
      srcRow * this.cellHeight,
      this.cellWidth,
      this.cellHeight,

      // Destination
      dstCol * this.cellWidth,
      dstRow * this.cellHeight,
      this.cellWidth,
      this.cellHeight
    )
  }
}

const local = document.currentScript.ownerDocument
AMaze.template = local.getElementById("a-maze").content

customElements.define('a-maze', AMaze)
</script>