/**
 * @file maze-engine.js
 * @author Frédéric BISSON <zigazou@free.fr>
 * @version 1.0
 *
 * MazeEngine handles every aspect of the game rules.
 */

/**
 * MazeEngine handles every aspect of the game rules.
 */
class MazeEngine {
    /**
     * Create a MazeEngine object.
     * @param {AMaze} maze Custom element drawing the maze on the screen.
     * @param {MessAgge} message Custom element showing message to the player.
     * @param {ScoreBoard} score Custom element showing the player score.
     */
    constructor(maze, message, score) {
        /**
         * The game map, an object derived from the JSON structure generated
         * by Tiled.
         * @member {Object}
         * @private
         */
        this.gameMap = {}

        /**
         * The grid of walls, physical objects the player can't go through.
         * @member {Object[][]}
         * @private
         */
        this.walls = [[]]

        /**
         * The list of interactive objects.
         * @member {Object[]}
         * @private
         */
        this.objects = []

        /**
         * The AMaze custom element on which to draw the game.
         * @member {AMaze}
         * @private
         */
        this.maze = maze

        /**
         * The message board on which messages and questions are shown to the
         * player.
         * @member {MessAge}
         * @private
         */
        this.message = message

        /**
         * The score board on which the player state is displayed.
         * @member {ScoreBoard}
         * @private
         */
        this.score = score

        /**
         * Current hero state.
         * @member {Object}
         * @private
         */
        this.hero = {
            x: 0,
            y: 0,
            health: 100,
            attack: 10,
            defense: 0,
            treasure: 0
        }

        /**
         * Indicates the engine is showing a message or a question to the hero.
         * If this is set to true, the engine ignores any player move.
         * @member {boolean}
         * @private
         */
        this.showingMessage = false

        /**
         * The promise that will be resolved when the game ends.
         * @member {Promise}
         * @private
         */
        this.endGame = undefined

        // Sets the score board with the initial hero state.
        this.score.setScore("health", this.hero.health)
        this.score.setScore("attack", this.hero.attack)
        this.score.setScore("defense", this.hero.defense)
        this.score.setScore("wealth", this.hero.treasure)
    }

    /**
     * Load the game map.
     * @param {Object} gameMap The game map as generated by Tiled.
     * @returns {Promise}
     */
    loadMap(gameMap) {
        this.gameMap = gameMap
        const sheetWidth = gameMap.tilesets[0].columns

        if(gameMap.properties) {
            // Custom properties generated by Tiled are not indexed by their
            // name. This creates this index which makes it easier later to
            // fetch specific properties.
            gameMap.properties.forEach(
                property => gameMap.properties[property.name] = property
            )
        }

        const layers = {
            "background": undefined,
            "decor": undefined,
            "objects": undefined,
            "walls": undefined
        }

        // Converts objects and layers generated by Tiled to better usable
        // structures.
        gameMap.layers.forEach(layer => {
            // Only works on predefined layer names.
            if(layer.name in layers) {
                if(layer.name === "objects") {
                    // Converts objects layer.
                    layers[layer.name] = MazeEngine.convertObjects(
                        layer.objects, sheetWidth
                    )
                } else {
                    // Converts tiled layers.
                    layers[layer.name] = MazeEngine.convertRawGrid(
                        layer.data, layer.width, sheetWidth
                    )
                }
            }
        })

        this.walls = layers.walls
        this.objects = layers.objects

        this.maze.loadGrid(
            layers.background,
            layers.decor,
            layers.objects,
            layers.walls
        ).then(() => {
            // By default, the maze works in darkness mode. If it is not enabled
            // in the game map, it must be disabled in the AMaze custom element.
            if(this.gameMap.properties.darkness.value === false) {
                this.maze.revealMap()
            }

            this.initHero(
                this.gameMap.properties.herosprite.value,
                this.gameMap.properties.startx.value,
                this.gameMap.properties.starty.value
            )
        })

        // Returns a promise that will be resolved when the game ends.
        return new Promise((resolve, reject) => {
            this.endGame = value => resolve(value)
        })
    }

    /**
     * Initializes the hero sprite and position.
     * @param {number} offset Offset of the hero in the tile set.
     * @param {number} col Starting column.
     * @param {number} row Starting row.
     */
    initHero(offset, col, row) {
        const srcCol = offset % this.gameMap.tilesets[0].columns
        const srcRow = Math.floor(offset / this.gameMap.tilesets[0].columns)

        this.maze.defineHero(srcCol, srcRow)
        this.moveHero(col, row)
    }

    /**
     * Move the hero either relatively or absolutely.
     * @param {mixed} dir If dir is "up", "down", "left" or "right", moves the
     *                    hero of 1 cell in the specified direction. Otherwise,
     *                    dir is the x position and the y parameter must be set.
     * @param {number?} y y position of the hero.
     */
    moveHero(dir, y) {
        // Do nothing if a message of question is shown to the player.
        if(this.showingMessage) return

        const directions = {
            "up": { x: 0, y: -1 },
            "down": { x: 0, y: 1 },
            "left": { x: -1, y: 0 },
            "right": { x: 1, y: 0 }
        }

        // Calculates new positions relatively or absolutely.
        const nx = directions[dir] ? this.hero.x + directions[dir].x : dir
        const ny = directions[dir] ? this.hero.y + directions[dir].y : y

        // The hero can not go through walls.
        if(this.walls[ny][nx].offset < 0) {
            const object = this.objectAt(nx, ny)

            if(object && object.visible) {
                // An object exists and is visible in the targeted cell.
                object.actions.forEach(action => {
                    const callbackName = "handleObject" + action.type

                    // Look for a callback corresponding to the object type.
                    if(callbackName in this) this[callbackName](
                        object, action.parameters
                    )
                })
            } else {
                // Just change the hero position.
                this.changePosition(nx, ny)
            }
        }
    }

    /**
     * Change the absolute hero position.
     * @param {number} x x cell coordinate.
     * @param {number} y y cell coordinate.
     * @private
     */
    changePosition(x, y) {
        this.maze.moveHero(x, y).switchOffTheLight().lighten(x, y)
        this.hero.x = x
        this.hero.y = y
    }

    /**
     * Delete an object from the objects layer.
     * @param {Object} object Object to delete.
     */
    deleteObject(object) {
        this.objects.find((o, index) => {
            if(o === object) {
                this.objects.splice(index, 1)
                return true
            }

            return false
        })
    }

    /**
     * Look for an object at specified coordinates.
     * @param {number} x x cell coordinate.
     * @param {number} y y cell coordinate.
     */
    objectAt(x, y) {
        return this.objects.find(object => object.x === x && object.y === y)
    }

    /**
     * Handles edible object type.
     * @param {Object} object The edible object.
     * @private
     */
    handleObjectedible(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            "You eat some…",
            object.name,
            "Your health increases"
        ).then(() => {
            this.deleteObject(object)
            this.hero.health += parameters[0]
            this.score.setScore("health", this.hero.health)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles inedible object type.
     * @param {Object} object The inedible object.
     * @private
     */
    handleObjectinedible(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            "You eat some…",
            object.name,
            "Your health decreases"
        ).then(() => {
            this.deleteObject(object)
            this.hero.health -= parameters[0]
            this.score.setScore("health", this.hero.health)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles show object type.
     * @param {Object} object The show object.
     * @private
     */
    handleObjectshow(object, parameters) {
        const targets = this.objects.filter(o => parameters.indexOf(o.id) >= 0)

        if(targets.length !== 0) {
            targets.forEach(object => object.visible = true)
            navigator.vibrate(50)
        }

        this.changePosition(object.x, object.y)
    }

    /**
     * Handles hide object type.
     * @param {Object} object The hide object.
     * @private
     */
    handleObjecthide(object, parameters) {
        const targets = this.objects.filter(o => parameters.indexOf(o.id) >= 0)

        if(targets.length !== 0) {
            targets.forEach(object => object.visible = false)
            navigator.vibrate([ 100, 30, 100])
        }

        this.changePosition(object.x, object.y)
    }

    /**
     * Handles showmap object type.
     * @param {Object} object The showmap object.
     * @private
     */
    handleObjectshowmap(object, parameters) {
        this.maze.revealMap()
        this.changePosition(object.x, object.y)
    }

    /**
     * Handles hidemap object type.
     * @param {Object} object The hidemap object.
     * @private
     */
    handleObjecthidemap(object, parameters) {
        this.maze.hideMap()
        this.changePosition(object.x, object.y)
    }

    /**
     * Handles weapon object type.
     * @param {Object} object The weapon object.
     * @private
     */
    handleObjectweapon(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            "You found…",
            object.name,
            "Your attack increases"
        ).then(() => {
            this.hero.attack += parameters[0]
            this.score.setScore("attack", this.hero.attack)
            this.deleteObject(object)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles secret object type.
     * @param {Object} object The secret object.
     * @private
     */
    handleObjectsecret(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            parameters[0],
            parameters[1],
            parameters[2]
        ).then(() => {
            this.deleteObject(object)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles protection object type.
     * @param {Object} object The protection object.
     * @private
     */
    handleObjectprotection(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            "You found…",
            object.name,
            "Your defense increases"
        ).then(() => {
            this.hero.defense += parameters[0]
            this.score.setScore("defense", this.hero.defense)
            this.deleteObject(object)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles treasure object type.
     * @param {Object} object The treasure object.
     * @private
     */
    handleObjecttreasure(object, parameters) {
        this.showingMessage = true
        this.message.showMessage(
            "You found…",
            object.name,
            "You are richer"
        ).then(() => {
            this.hero.treasure += parameters[0]
            this.score.setScore("wealth", this.hero.treasure)
            this.deleteObject(object)
            this.changePosition(object.x, object.y)
            this.showingMessage = false
        })
    }

    /**
     * Handles teleport object type.
     * @param {Object} object The teleport object.
     * @private
     */
    handleObjectteleport(object, parameters) {
        const destination = this.objects.find(o => o.id === parameters[0])

        this.changePosition(destination.x, destination.y)
    }

    /**
     * Handles win object type.
     * @param {Object} object The win object.
     * @private
     */
    handleObjectwin(object, parameters) {
        this.message.showMessage(
            parameters[0],
            parameters[1],
            parameters[2]
        ).then(() => this.endGame())
    }

    /**
     * Handles inedible question type.
     * @param {Object} object The question object.
     * @private
     */
    handleObjectquestion(object, parameters) {
        let success = false

        this.showingMessage = true

        this.message.showQuestion(
            "A right answer open the way",
            parameters[0],
            parameters.slice(1, 5)
        ).then(answer => {
            if(answer === parameters[5]) {
                success = true
                return this.message.showMessage(
                    "You have given...",
                    "The right answer!",
                    "I will clear the way."
                )
            } else {
                return this.message.showMessage(
                    "You have given...",
                    "The wrong answer!",
                    "Come to me later when you figure the right answer."
                )
            }
        }).then(() => {
            if(success) {
                this.deleteObject(object)
                this.changePosition(object.x, object.y)
            }

            this.showingMessage = false
        })
    }
}

/**
 * Converts object objects from the Tiled application.
 * @param {Object[]} objects List of objects to convert.
 * @param {number} sheetWidth Tile sheet width in number of tiles.
 * @param {Object[]}
 */
MazeEngine.convertObjects = function(objects, sheetWidth) {
    return objects.map(object => {
        // Converts offsets to 2d coordinates.
        const coords = MazeEngine.offsetToCoordinates(object.gid, sheetWidth)
        object.offset = coords.offset
        object.srcX = coords.x
        object.srcY = coords.y
        object.x = object.x / object.width
        object.y = object.y / object.height - 1

        // Search for the actions property.
        if(object.properties) {
            object.properties.forEach(property => {
                if(property.name === "actions") {
                    const compiler = new ActionCompiler()
                    object.actions = compiler.compile(property.value)
                }
            })
        }

        return object
    })
}

/**
 * Converts an offset given by Tiled to 2d coordinates.
 * @param {number} offset Offset given by Tiled.
 * @param {number} sheetWidth Tile sheet width in number of tiles.
 */
MazeEngine.offsetToCoordinates = function(offset, sheetWidth) {
    // The zero offset means no for Tiled.
    offset--

    return {
        x: offset % sheetWidth,
        y: Math.floor(offset / sheetWidth),
        offset: offset
    }
}

/**
 * Converts a list of offsets given by Tiled to 2d coordinates.
 * @param {number[]} offsets Offsets given by Tiled.
 * @param {number} sWidth Til sheet width in number of tiles.
 * @returns {number[]}
 */
MazeEngine.offsetsToCoordinates = function(offsets, sWidth) {
    return offsets.map(offset => MazeEngine.offsetToCoordinates(offset, sWidth))
}

/**
 * Converts a raw grid to a grid more suitable to a MazeEngine object.
 * @param {Object[]} rawGrid The raw grid to convert.
 * @param {number} gridWidth Grid width in number of tiles.
 * @param {number} sheetWidth Tile sheet width in number of tiles.
 * @returns {Object[][]}
 */
MazeEngine.convertRawGrid = function(rawGrid, gridWidth, sheetWidth) {
    return rawGrid.reduce((all, one, i) => {
        // Converts the 1 dimensional array to a 2 dimensional array.
        const ch = Math.floor(i / gridWidth)
        all[ch] = [].concat(all[ch] || [], one)
        return all
    }, []).map(row => MazeEngine.offsetsToCoordinates(row, sheetWidth))
}
